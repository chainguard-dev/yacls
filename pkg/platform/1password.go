package platform

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/gocarina/gocsv"
)

type onePasswordTeamRecord struct {
	TeamMember string `csv:"Team Member"`
	Email      string `csv:"Email"`
	Status     string `csv:"Status"`
	TwoFactor  bool   `csv:"Two-Factor Authentication"`
}

// OnePasswordTeam parses the CSV file generated by the OnePassword Team page.
type OnePasswordTeam struct{}

func (p *OnePasswordTeam) Description() ProcessorDescription {
	return ProcessorDescription{
		Kind: "1password",
		Name: "1Password Team Members",
		Steps: []string{
			"To be documented",
			"Download resulting CSV file for analysis",

			"Execute 'yacls --kind={{.Kind}} --input={{.Path}}'",
		},
		MatchingFilename: regexp.MustCompile(`^.* Team Report \d+-\d+-\d+.csv$`),
	}
}

func (p *OnePasswordTeam) Process(c Config) (*Artifact, error) {
	src, err := NewSourceFromConfig(c, p)
	if err != nil {
		return nil, fmt.Errorf("source: %w", err)
	}
	a := &Artifact{Metadata: src}

	records := []onePasswordTeamRecord{}
	if err := gocsv.UnmarshalBytes(src.content, &records); err != nil {
		return nil, fmt.Errorf("unmarshal: %w", err)
	}

	for _, r := range records {
		// Reduce output spam
		if r.Status == "Active" {
			r.Status = ""
		}

		u := User{
			Account:           r.Email,
			Name:              strings.TrimSpace(r.TeamMember),
			Status:            r.Status,
			TwoFactorDisabled: !r.TwoFactor,
		}

		a.Users = append(a.Users, u)
	}

	return a, nil
}
